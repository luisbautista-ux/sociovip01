
"use client";

import { useState, useEffect } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { QrCode, ListChecks, Gift, Search, AlertTriangle } from "lucide-react";
import type { BusinessManagedEntity, GeneratedCode, PromoterProfile } from "@/lib/types";
import { format } from "date-fns";
import { es } from "date-fns/locale";
import { CreateCodesDialog } from "@/components/business/dialogs/CreateCodesDialog";
import { ManageCodesDialog } from "@/components/business/dialogs/ManageCodesDialog";
import { useToast } from "@/hooks/use-toast";
import { Input } from "@/components/ui/input";

// Mock data - In a real app, this would be fetched based on the logged-in promoter
const mockLoggedInPromoter: PromoterProfile = {
  id: "pp1",
  name: "Carlos Santana (Promotor)",
  email: "carlos.santana@promo.com",
  phone: "+51911223344"
};

// Assume these entities are assigned to mockLoggedInPromoter
// This association would come from the backend (e.g., BusinessPromoterLink or a field in BusinessManagedEntity)
let mockAssignedEntities: BusinessManagedEntity[] = [
  { 
    id: "bp1", 
    businessId: "biz1", 
    type: "promotion", 
    name: "Jueves de Alitas BBQ (Asignada a Carlos)", 
    description: "Todas las alitas BBQ a S/1 cada una.", 
    startDate: "2024-08-01T12:00:00", 
    endDate: "2024-12-31T12:00:00", 
    usageLimit: 0, 
    isActive: true, 
    imageUrl: "https://placehold.co/300x200.png", 
    aiHint: "chicken wings",
    generatedCodes: [ // Codes can be generated by business or promoter
        { id: "codePromo1-1", entityId: "bp1", value: "ALITAS001", status: "available", generatedByName: "Admin Negocio", generatedDate: "2024-07-20T10:00:00Z" },
        { id: "pp1bp1cd1", entityId: "bp1", value: "PROMOALAS", status: "available", generatedByName: mockLoggedInPromoter.name, generatedDate: "2024-08-02T10:00:00Z", observation: "Códigos Promotor Carlos" },
    ]
  },
  { 
    id: "evt1", 
    businessId: "biz1", 
    type: "event", 
    name: "Noche de Karaoke Estelar (Asignada a Carlos)", 
    description: "Saca la estrella que llevas dentro.", 
    startDate: "2024-08-15T12:00:00", 
    endDate: "2024-08-15T12:00:00", 
    maxAttendance: 100, 
    isActive: true, 
    imageUrl: "https://placehold.co/300x200.png", 
    aiHint: "karaoke night",
    generatedCodes: [
        { id: "pp1evt1cd1", entityId: "evt1", value: "VOZSTAR01", status: "redeemed", generatedByName: mockLoggedInPromoter.name, generatedDate: "2024-08-05T10:00:00Z", redemptionDate: "2024-08-15T21:00:00Z", redeemedByInfo: {dni: "11223344", name: "Test User"} },
    ]
  },
   { 
    id: "bpInactive", 
    businessId: "biz1", 
    type: "promotion", 
    name: "Promo Pasada (Asignada a Carlos)", 
    description: "Esta promoción ya no está activa.", 
    startDate: "2024-06-01T12:00:00", 
    endDate: "2024-06-30T12:00:00", 
    usageLimit: 0, 
    isActive: false, // Important: inactive
    imageUrl: "https://placehold.co/300x200.png", 
    aiHint: "old deal",
    generatedCodes: []
  },
];

export default function PromoterEntitiesPage() {
  const [entities, setEntities] = useState<BusinessManagedEntity[]>(mockAssignedEntities);
  const [searchTerm, setSearchTerm] = useState("");
  const { toast } = useToast();

  const [showCreateCodesModal, setShowCreateCodesModal] = useState(false);
  const [selectedEntityForCreatingCodes, setSelectedEntityForCreatingCodes] = useState<BusinessManagedEntity | null>(null);
  
  const [showManageCodesModal, setShowManageCodesModal] = useState(false);
  const [selectedEntityForViewingCodes, setSelectedEntityForViewingCodes] = useState<BusinessManagedEntity | null>(null);

  const filteredEntities = entities.filter(entity =>
    entity.name.toLowerCase().includes(searchTerm.toLowerCase()) && entity.isActive // Show only active entities by default for promoter
  );
  
  const openCreateCodesDialog = (entity: BusinessManagedEntity) => {
    if (!entity.isActive || new Date(entity.endDate) < new Date() || new Date(entity.startDate) > new Date()) {
      toast({ title: "No se pueden crear códigos", description: "La entidad no está activa o está fuera de su periodo de vigencia.", variant: "destructive"});
      return;
    }
    setSelectedEntityForCreatingCodes(entity);
    setShowCreateCodesModal(true);
  };

  const openViewCodesDialog = (entity: BusinessManagedEntity) => {
    setSelectedEntityForViewingCodes(entity);
    setShowManageCodesModal(true);
  };

  const handleNewCodesCreated = (entityId: string, newCodes: GeneratedCode[], observation?: string) => {
    setEntities(prevEntities => prevEntities.map(entity => {
      if (entity.id === entityId) {
        const codesWithPromoterName = newCodes.map(code => ({
          ...code,
          generatedByName: mockLoggedInPromoter.name, // Ensure promoter's name is set
          observation: observation || code.observation // Apply batch observation
        }));
        const updatedCodes = [...(entity.generatedCodes || []), ...codesWithPromoterName];
        return { ...entity, generatedCodes: updatedCodes };
      }
      return entity;
    }));
  };
  
  // This function primarily updates the local state for ManageCodesDialog.
  // Deletion of codes generated by others shouldn't be allowed for a promoter.
  // ManageCodesDialog should be adapted or a specific PromoterManageCodesDialog created
  // if stricter permission for deletion is needed. For now, it reuses the existing one.
  const handleCodesUpdatedFromManageDialog = (entityId: string, updatedCodes: GeneratedCode[]) => {
     setEntities(prevEntities => prevEntities.map(entity => 
      entity.id === entityId ? { ...entity, generatedCodes: updatedCodes } : entity
    ));
  };
  
  const getCodesGeneratedByPromoterCount = (entity: BusinessManagedEntity) => {
    return entity.generatedCodes?.filter(c => c.generatedByName === mockLoggedInPromoter.name).length || 0;
  };

  return (
    <div className="space-y-6">
      <h1 className="text-3xl font-bold text-primary flex items-center">
        <Gift className="h-8 w-8 mr-2" /> Mis Entidades Asignadas
      </h1>
      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle>Promociones y Eventos Activos para Ti</CardTitle>
          <CardDescription>Aquí puedes generar códigos para las entidades que te han sido asignadas y están activas.</CardDescription>
          <div className="relative mt-4">
            <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input
              type="search"
              placeholder="Buscar por nombre..."
              className="pl-8 w-full sm:w-[300px]"
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
          </div>
        </CardHeader>
        <CardContent>
          {filteredEntities.length > 0 ? (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Nombre Entidad</TableHead>
                  <TableHead>Tipo</TableHead>
                  <TableHead className="hidden md:table-cell">Vigencia</TableHead>
                  <TableHead className="text-center">Mis Códigos</TableHead>
                  <TableHead className="text-right">Acciones</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {filteredEntities.map((entity) => (
                  <TableRow key={entity.id}>
                    <TableCell className="font-medium">{entity.name}</TableCell>
                    <TableCell>
                      <Badge variant="outline">{entity.type === 'promotion' ? 'Promoción' : 'Evento'}</Badge>
                    </TableCell>
                    <TableCell className="hidden md:table-cell">
                      {format(new Date(entity.startDate), "P", { locale: es })} - {format(new Date(entity.endDate), "P", { locale: es })}
                    </TableCell>
                    <TableCell className="text-center">{getCodesGeneratedByPromoterCount(entity)}</TableCell>
                    <TableCell className="text-right space-x-1">
                      <Button variant="default" size="sm" onClick={() => openCreateCodesDialog(entity)} 
                              disabled={!entity.isActive || new Date(entity.endDate) < new Date() || new Date(entity.startDate) > new Date()}
                              className="bg-primary hover:bg-primary/90">
                        <QrCode className="h-4 w-4 mr-1" /> Crear Códigos
                      </Button>
                       <Button variant="outline" size="sm" onClick={() => openViewCodesDialog(entity)}>
                        <ListChecks className="h-4 w-4 mr-1" /> Ver Mis Códigos
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          ) : (
            <div className="flex flex-col items-center justify-center h-40 text-muted-foreground border border-dashed rounded-md p-4 text-center">
                <AlertTriangle className="h-10 w-10 mb-2 text-yellow-500"/>
                <p className="font-semibold">No tienes entidades activas asignadas que coincidan con tu búsqueda.</p>
                <p className="text-sm">Si esperabas ver alguna, contacta al administrador del negocio.</p>
            </div>
          )}
        </CardContent>
      </Card>

      {selectedEntityForCreatingCodes && (
        <CreateCodesDialog
          open={showCreateCodesModal}
          onOpenChange={setShowCreateCodesModal}
          entityName={selectedEntityForCreatingCodes.name}
          entityId={selectedEntityForCreatingCodes.id}
          // Pass only promoter's codes for uniqueness check if needed, or all if simpler for now.
          // For simplicity, passing all and letting dialog handle general uniqueness.
          existingCodesValues={(selectedEntityForCreatingCodes.generatedCodes || []).map(c => c.value)}
          onCodesCreated={handleNewCodesCreated}
        />
      )}

      {selectedEntityForViewingCodes && (
        <ManageCodesDialog
          open={showManageCodesModal}
          onOpenChange={(isOpen) => {
            setShowManageCodesModal(isOpen);
            if (!isOpen) setSelectedEntityForViewingCodes(null);
          }}
          entity={{ // Pass a modified entity that only contains codes generated by this promoter
            ...selectedEntityForViewingCodes,
            generatedCodes: selectedEntityForViewingCodes.generatedCodes?.filter(
              c => c.generatedByName === mockLoggedInPromoter.name
            ) || []
          }}
          onCodesUpdated={handleCodesUpdatedFromManageDialog}
          onRequestCreateNewCodes={() => {
            setShowManageCodesModal(false);
             if(selectedEntityForViewingCodes) {
                // Ensure the original entity (with all codes for uniqueness check) is passed to CreateCodesDialog
                const originalEntity = entities.find(e => e.id === selectedEntityForViewingCodes.id);
                if (originalEntity) {
                    setTimeout(() => openCreateCodesDialog(originalEntity), 0);
                }
            }
          }}
        />
      )}
    </div>
  );
}
