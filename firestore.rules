
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ================== HELPER FUNCTIONS ==================
    function isSignedIn() {
      return request.auth != null;
    }

    function getUserData(userId) {
      return get(/databases/$(database)/documents/platformUsers/$(userId)).data;
    }

    function isSuperAdmin() {
      return isSignedIn() && 'superadmin' in getUserData(request.auth.uid).roles;
    }
    
    function isStaffOfBusiness(businessId) {
      if (!isSignedIn()) { return false; }
      let userData = getUserData(request.auth.uid);
      return userData.businessId == businessId && 
             userData.roles.hasAny(['business_admin', 'staff', 'host']);
    }
    
    function isBusinessAdmin(businessId) {
        if (!isSignedIn()) { return false; }
        let userData = getUserData(request.auth.uid);
        return userData.businessId == businessId && 'business_admin' in userData.roles;
    }

    // ================== COLLECTION RULES ==================

    // Businesses: Publicly readable, only superadmins can modify.
    match /businesses/{businessId} {
      allow read: if true;
      allow write: if isSuperAdmin();
    }
    
    // Platform Users: Controlled access based on roles.
    match /platformUsers/{userId} {
      // READ: Superadmin can read anyone. Business staff can read users of the same business.
      allow get: if isSuperAdmin() || (isSignedIn() && getUserData(request.auth.uid).businessId == getUserData(userId).businessId);
      allow list: if isSignedIn(); // List is expensive, further filtering done in client/backend queries.

      // CREATE: Handled by a backend API route (create-user) which has its own logic.
      // We can add a rule here to only allow that API to write, but for now we trust the backend.
      // This rule allows SuperAdmins to create users directly if needed.
      allow create: if isSuperAdmin();

      // UPDATE: Superadmin can update anyone. Business admin can update staff/host of their own business.
      allow update: if isSuperAdmin() || 
                     (isBusinessAdmin(resource.data.businessId) && 
                      request.auth.uid != userId && // Admin cannot change their own role here
                      (resource.data.roles.hasAny(['staff', 'host'])));

      // DELETE: Superadmin can delete anyone. Business admin can delete staff/host of their own business.
      allow delete: if isSuperAdmin() || 
                     (isBusinessAdmin(getUserData(userId).businessId) && request.auth.uid != userId);
    }
    
    // QR Clients: Read by business staff, write is handled by public page logic (not authenticated)
    match /qrClients/{clientId} {
      allow read: if isSignedIn() && isStaffOfBusiness(resource.data.generatedForBusinessId);
      allow list: if isSignedIn(); // Filtered by client
      allow create: if true; // Public page creates this
      allow update, delete: if false; // Should not be modified/deleted from client
    }
    
    // Socio VIP Members: Only readable/writable by SuperAdmins
    match /socioVipMembers/{memberId} {
      allow read, write: if isSuperAdmin();
    }
    
    // Business Entities (Promos/Events): Readable by public, writable by staff of the correct business
    match /businessEntities/{entityId} {
      allow read: if true;
      allow create, update, delete: if isSignedIn() && isStaffOfBusiness(request.resource.data.businessId);
    }

    // Promoter Links: Readable/writable by staff of the correct business
    match /businessPromoterLinks/{linkId} {
      allow read, write: if isSignedIn() && isStaffOfBusiness(request.resource.data.businessId);
    }
  }
}
